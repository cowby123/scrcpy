<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>scrcpy WebRTC Demo</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin:0; background:#111; display:flex; gap:16px;
      flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial;
    }
    header { color:#ddd; opacity:.9; }
    video {
      width:min(92vw, 900px);
      max-height:80vh;
      background:black;
      border-radius:12px;
      box-shadow:0 6px 30px rgba(0,0,0,.35);
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      object-fit: contain;
    }
    .row { display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
    button { padding:10px 16px; border-radius:10px; border:1px solid #333; background:#1f1f1f; color:#ddd; cursor:pointer; }
    button:hover { background:#262626; }
    pre { width:min(92vw, 900px); max-height:22vh; overflow:auto; background:#0c0c0c; color:#bbb; border:1px solid #222; border-radius:10px; padding:10px; }
  </style>
</head>
<body>
  <header>
    <h2>scrcpy WebRTC Demo</h2>
  </header>

  <video id="video" autoplay playsinline muted
         disablepictureinpicture
         disableremoteplayback
         controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"></video>

  <div class="row">
    <select id="deviceSelect" style="padding:10px; border-radius:8px; border:1px solid #333; background:#1f1f1f; color:#ddd; min-width:200px;">
      <option value="">è¼‰å…¥ä¸­...</option>
    </select>
    <button id="btnRefresh">åˆ·æ–°è¨­å‚™åˆ—è¡¨</button>
    <button id="btnStart">é–‹å§‹é€£ç·š</button>
    <button id="btnStop" disabled>ä¸­æ–·é€£ç·š</button>
  </div>

  <pre id="log" aria-label="log"></pre>

  <script>
    const $ = (s)=>document.querySelector(s);
    const videoEl = $("#video");
    let pc, dcR, dcU; // reliable / unreliable
    let forceStop = false;
    const BLOCK_KEYS = [" ", "k", "MediaPlayPause"];
    
    // è¼‰å…¥è¨­å‚™åˆ—è¡¨
    async function loadDevices() {
      try {
        const resp = await fetch('/devices');
        const data = await resp.json();
        const select = $("#deviceSelect");
        select.innerHTML = '';
        
        if (data.devices && data.devices.length > 0) {
          data.devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.ip;
            
            // æ§‹å»ºé¡¯ç¤ºæ–‡å­—ï¼ŒåŒ…å«ç‹€æ…‹å’Œè§£æåº¦è³‡è¨Š
            let displayText = device.ip;
            
            if (device.state === 'device') {
              displayText += ' âœ“'; // åœ¨ç·š
            } else if (device.state === 'offline') {
              displayText += ' âš  (é›¢ç·š)';
              option.disabled = true;
            } else if (device.state === 'unauthorized') {
              displayText += ' ğŸ”’ (æœªæˆæ¬Š)';
              option.disabled = true;
            } else {
              displayText += ` (${device.state})`;
            }
            
            if (device.connected && device.videoW && device.videoH) {
              displayText += ` [å·²é€£ç·š ${device.videoW}x${device.videoH}]`;
            }
            
            option.textContent = displayText;
            select.appendChild(option);
          });
          log(`å·²è¼‰å…¥ ${data.devices.length} å€‹è¨­å‚™`);
        } else {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'ç„¡å¯ç”¨è¨­å‚™';
          select.appendChild(option);
          log('ç„¡å¯ç”¨è¨­å‚™');
        }
      } catch (e) {
        log('è¼‰å…¥è¨­å‚™åˆ—è¡¨å¤±æ•—:', e.message);
        const select = $("#deviceSelect");
        select.innerHTML = '<option value="">è¼‰å…¥å¤±æ•—</option>';
      }
    }
    
    // ç²å–é¸ä¸­çš„è¨­å‚™ IP ä½œç‚ºå®¢æˆ¶ç«¯ ID
    function getClientId() {
      const selectedDevice = $("#deviceSelect").value;
      if (selectedDevice) {
        return selectedDevice;
      }
      
      // å¦‚æœæ²’æœ‰é¸æ“‡è¨­å‚™ï¼Œä½¿ç”¨ URL åƒæ•¸æˆ–éš¨æ©Ÿç”Ÿæˆ
      const urlParams = new URLSearchParams(window.location.search);
      const urlId = urlParams.get('id');
      if (urlId) return urlId;
      
      return 'client-' + Math.random().toString(36).substr(2, 9);
    }

    // è¿½è¹¤ç›®å‰ã€ŒæŒ‰ä½ã€çš„ pointersï¼Œä¾¿æ–¼é é¢åˆ‡æ›æ™‚è£œé€ cancel
    const activePointers = new Set();

    const log = (...args) => {
      const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
      $("#log").textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      $("#log").scrollTop = $("#log").scrollHeight;
      console.log(...args);
    };

    // æ°¸ä¹…é—œé–‰ä»»ä½•æ’­æ”¾æ§åˆ¶èˆ‡èœå–®
    videoEl.controls = false;
    videoEl.setAttribute("disablepictureinpicture", "");
    videoEl.setAttribute("disableremoteplayback", "");
    videoEl.setAttribute("controlslist", "nodownload noplaybackrate noremoteplayback nofullscreen");
    videoEl.addEventListener("contextmenu", e => e.preventDefault());
    ["click","dblclick"].forEach(type => videoEl.addEventListener(type, e => e.preventDefault(), { capture:true }));
    videoEl.addEventListener("pause", () => { if (!forceStop) videoEl.play().catch(()=>{}); });
    window.addEventListener("keydown", (e) => { if (BLOCK_KEYS.includes(e.key)) e.preventDefault(); }, { capture: true });

    // ======= é¡¯ç¤ºå€èˆ‡åº§æ¨™æ›ç®—ï¼ˆæ‰£é»‘é‚Š â†’ åŸç”Ÿåƒç´ ï¼‰=======
    function computeDisplayRect() {
      const r = videoEl.getBoundingClientRect();
      const vw = videoEl.videoWidth  || r.width;
      const vh = videoEl.videoHeight || r.height;
      const scale = Math.min(r.width / vw, r.height / vh);
      const displayW = vw * scale;
      const displayH = vh * scale;
      const offsetX = (r.width  - displayW) / 2;
      const offsetY = (r.height - displayH) / 2;
      return { box: r, vw, vh, displayW, displayH, offsetX, offsetY };
    }

    function mapToVideoPixel(e) {
      const { box: r, vw, vh, displayW, displayH, offsetX, offsetY } = computeDisplayRect();
      const xPx = e.clientX - r.left - offsetX;
      const yPx = e.clientY - r.top  - offsetY;
      if (xPx < 0 || yPx < 0 || xPx > displayW || yPx > displayH) return { inside: false };
      const nx = displayW > 0 ? (xPx / displayW) : 0;
      const ny = displayH > 0 ? (yPx / displayH) : 0;
      const ix = Math.round(nx * vw);
      const iy = Math.round(ny * vh);
      return { inside: true, ix, iy };
    }

    // ======= DataChannelï¼šå¯é /ä¸å¯é  =======
    function dcOpen(dc)  { log(`DataChannel open: ${dc.label} (ordered=${dc.ordered}, maxRetransmits=${dc.maxRetransmits ?? "âˆ"})`); }
    function dcClose(dc) { log(`DataChannel closed: ${dc.label}`); }
    function dcError(dc, e) { log(`DataChannel error: ${dc.label}`, e?.message || e); }

    function sendOn(dc, payload) {
      if (!dc || dc.readyState !== "open") return false;
      try {
        const txt = JSON.stringify(payload);
        dc.send(txt);
        return true;
      } catch (e) {
        log("DC send error", e?.message || e);
        return false;
      }
    }

    function sendControl(payload, reliable = true) {
      // åŠ ä¸Š video åŸç”Ÿå¯¬é«˜èˆ‡ pointerType
      payload.screenW = videoEl.videoWidth  | 0;
      payload.screenH = videoEl.videoHeight | 0;
      // æŒ‰éˆ•èˆ‡å£“åŠ›æ•¸å€¼æ²¿ç”¨
      if (reliable) {
        if (sendOn(dcR, payload)) return true;
        return sendOn(dcU, payload);
      } else {
        if (sendOn(dcU, payload)) return true;
        return sendOn(dcR, payload);
      }
    }

    // ======= PointerEvent â†’ Android MotionEvent å°æ˜  =======
    // DOM event.button: [0]=Left, [1]=Middle, [2]=Right, [3]=Back, [4]=Forward
    // Android MotionEventButton: Primary(1), Tertiary(4), Secondary(2), Back(8), Forward(16)
    const PointerEventButtonToAndroidButton = [1, 4, 2, 8, 16];

    let lastMoveSent = 0;
    const MOVE_INTERVAL_MS = 10; // è¼•å¾®ç¯€æµé¿å…æ“å¡

    function sendTouch(type, e) {
      const m = mapToVideoPixel(e);
      if (!m.inside) return;

      // ä¾äº‹ä»¶å‹åˆ¥å¡« actionButton
      let actionButton = 0;
      if (type === "down" || type === "up") {
        const idx = e.button ?? 0;
        actionButton = PointerEventButtonToAndroidButton[idx] || 1;
      }

      const payload = {
        type,                 // "down" | "move" | "up" | "cancel"
        id: e.pointerId,
        x: m.ix, y: m.iy,
        pressure: e.pressure ?? 0,
        buttons:  e.buttons  ?? 0,
        actionButton,
        pointerType: e.pointerType || "mouse"
      };

      if (type === "move") {
        const now = performance.now();
        if (now - lastMoveSent < MOVE_INTERVAL_MS) return;
        lastMoveSent = now;
        sendControl(payload, /*reliable=*/false);
      } else {
        // down/up/cancel ä¸€å¾‹å¯é é€šé“ï¼Œé¿å…éºå¤±
        sendControl(payload, /*reliable=*/true);
        log(`touch:${type}`, payload);
      }
    }

    // æŒ‡é‡äº‹ä»¶ï¼ˆå¤šæŒ‡ï¼‰
    videoEl.addEventListener("pointerdown", (e) => {
      videoEl.setPointerCapture?.(e.pointerId);
      activePointers.add(e.pointerId);
      sendTouch("down", e);
      e.preventDefault();
    }, { passive:false });

    videoEl.addEventListener("pointermove", (e) => {
      if (e.pressure !== 0 || e.buttons) sendTouch("move", e);
      e.preventDefault();
    }, { passive:false });

    function finishPointer(e, kind) {
      try { videoEl.releasePointerCapture?.(e.pointerId); } catch {}
      activePointers.delete(e.pointerId);
      sendTouch(kind, e);
    }

    videoEl.addEventListener("pointerup", (e) => {
      finishPointer(e, "up");
      e.preventDefault();
    }, { passive:false });

    videoEl.addEventListener("pointercancel", (e) => {
      finishPointer(e, "cancel");
      e.preventDefault();
    }, { passive:false });

    // é é¢åˆ‡æ›/éš±è—æ™‚ï¼Œä¿éšªè£œé€ cancelï¼ˆé¿å…æ®˜ç•™æŒ‰ä½ç‹€æ…‹ï¼‰
    function cancelAllActivePointers() {
      for (const id of Array.from(activePointers)) {
        const fake = new PointerEvent("pointercancel", { pointerId: id, clientX: 0, clientY: 0, buttons: 0, pressure: 0 });
        finishPointer(fake, "cancel");
      }
    }
    window.addEventListener("visibilitychange", () => { if (document.hidden) cancelAllActivePointers(); });
    window.addEventListener("pagehide", cancelAllActivePointers);
    window.addEventListener("beforeunload", cancelAllActivePointers);

    // é¡¯ç¤ºå½±ç‰‡å°ºå¯¸è®ŠåŒ–
    videoEl.addEventListener("loadedmetadata", () => {
      const r = videoEl.getBoundingClientRect();
      log("video meta", { vw: videoEl.videoWidth, vh: videoEl.videoHeight, cw: Math.round(r.width), ch: Math.round(r.height) });
    });

    // ======= WebRTC =======
    function waitForIceComplete(pc) {
      return new Promise(resolve => {
        if (pc.iceGatheringState === "complete") return resolve();
        function check() {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", check);
            resolve();
          }
        }
        pc.addEventListener("icegatheringstatechange", check);
      });
    }

    async function start() {
      try {
        $("#btnStart").disabled = true;
        $("#btnStop").disabled = false;
        forceStop = false;
        
        // å–å¾—å®¢æˆ¶ç«¯ ID
        const clientId = getClientId();
        log(`æº–å‚™é€£ç·šï¼Œå®¢æˆ¶ç«¯ ID: ${clientId}`);

        pc = new RTCPeerConnection();

        // æ§åˆ¶ç”¨é›™é€šé“
        dcR = pc.createDataChannel("controlR", { ordered: true });
        dcU = pc.createDataChannel("controlU", { ordered: false, maxRetransmits: 0 });
        [dcR, dcU].forEach(dc => {
          dc.onopen  = () => dcOpen(dc);
          dc.onclose = () => dcClose(dc);
          dc.onerror = (e) => dcError(dc, e);
        });

        // é¡¯ç¤ºé ç«¯å½±åƒ
        pc.ontrack = (e) => {
          if (!videoEl.srcObject) {
            videoEl.srcObject = e.streams[0];
            videoEl.play().catch(()=>{});
          }
        };

        // æ”¶è¦–è¨Šï¼ˆrecvonlyï¼‰ï¼Œå„ªå…ˆ H.264
        const transceiver = pc.addTransceiver("video", { direction: "recvonly" });
        const caps = RTCRtpReceiver.getCapabilities("video");
        if (caps && caps.codecs) {
          const h264 = caps.codecs.filter(c => (c.mimeType || c.mimeTypeCanonical || '').toLowerCase() === "video/h264");
          if (h264.length) {
            transceiver.setCodecPreferences(h264);
            log("ä½¿ç”¨ H.264 codec åå¥½ã€‚");
          } else {
            log("æ‰¾ä¸åˆ° H.264 èƒ½åŠ›ï¼Œç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´ã€‚");
          }
        }

        pc.onconnectionstatechange     = () => log("PeerConnection:", pc.connectionState);
        pc.oniceconnectionstatechange  = () => log("ICE:", pc.iceConnectionState);
        pc.onicegatheringstatechange   = () => log("ICE Gathering:", pc.iceGatheringState);
        pc.onicecandidateerror         = (e) => log("ICE Candidate Error:", e.errorText || e);

        // SDP äº¤æ›ï¼ˆnon-trickleï¼‰
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceComplete(pc);

        // ç™¼é€ offer æ™‚å¸¶ä¸Šå®¢æˆ¶ç«¯ ID
        const resp = await fetch(`/offer?id=${encodeURIComponent(clientId)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(pc.localDescription),
        });
        if (!resp.ok) throw new Error(`Offer é€å‡ºå¤±æ•—: ${resp.status} ${resp.statusText}`);
        const answer = await resp.json();

        await pc.setRemoteDescription(answer);
        log("WebRTC å·²é€£ç·šï¼Œç­‰å¾…ç•«é¢â€¦");
      } catch (err) {
        log("é€£ç·šç™¼ç”ŸéŒ¯èª¤ï¼š", err);
        $("#btnStart").disabled = false;
        $("#btnStop").disabled = true;
      }
    }

    async function stop() {
      try {
        $("#btnStop").disabled = true;
        forceStop = true; // é˜²æ­¢ pause äº‹ä»¶è‡ªå‹•æ¢å¾©æ’­æ”¾
        cancelAllActivePointers();
        if (pc) {
          pc.getTransceivers().forEach(t => t.stop && t.stop());
          pc.getSenders().forEach(s => s.track && s.track.stop());
          pc.getReceivers().forEach(r => r.track && r.track.stop());
          pc.close();
          pc = null;
        }
        if (videoEl.srcObject) {
          videoEl.srcObject.getTracks().forEach(t => t.stop());
          videoEl.srcObject = null;
        }
        log("å·²ä¸­æ–·é€£ç·šã€‚");
      } finally {
        $("#btnStart").disabled = false;
      }
    }

    $("#btnStart").addEventListener("click", start);
    $("#btnStop").addEventListener("click", stop);
    $("#btnRefresh").addEventListener("click", loadDevices);

    // é é¢è¼‰å…¥æ™‚å…ˆè¼‰å…¥è¨­å‚™åˆ—è¡¨
    loadDevices().then(() => {
      log("è¨­å‚™åˆ—è¡¨å·²è¼‰å…¥ï¼Œè«‹é¸æ“‡è¨­å‚™å¾Œé»æ“Šã€Œé–‹å§‹é€£ç·šã€");
    });
  </script>
</body>
</html>
