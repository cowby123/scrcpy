<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>scrcpy WebRTC Demo</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin:0; background:#111; display:flex; gap:16px;
      flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial;
    }
    header { color:#ddd; opacity:.9; }
    video {
      width:min(92vw, 900px);
      max-height:80vh;
      background:black;
      border-radius:12px;
      box-shadow:0 6px 30px rgba(0,0,0,.35);
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      object-fit: contain;
    }
    .row { display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
    button { padding:10px 16px; border-radius:10px; border:1px solid #333; background:#1f1f1f; color:#ddd; cursor:pointer; }
    button:hover { background:#262626; }
    input[type="text"] { padding:10px 12px; border-radius:10px; border:1px solid #333; background:#1b1b1b; color:#ddd; min-width:220px; }
    input[type="text"]::placeholder { color:#777; }
    pre { width:min(92vw, 900px); max-height:22vh; overflow:auto; background:#0c0c0c; color:#bbb; border:1px solid #222; border-radius:10px; padding:10px; }
  </style>
</head>
<body>
  <header>
    <h2>scrcpy WebRTC Demo</h2>
  </header>

  <video id="video" autoplay playsinline muted
         disablepictureinpicture
         disableremoteplayback
         controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"></video>

  <div class="row">
    <input id="adbTarget" type="text" placeholder="ADB 目標（例如 192.168.1.10:5555）" aria-label="adb target" />
    <button id="btnStart">開始連線</button>
    <button id="btnStop" disabled>中斷連線</button>
    <button id="btnReconnectAndroid">重新連接 Android</button>
  </div>

  <pre id="log" aria-label="log"></pre>

  <script>
    const $ = (s)=>document.querySelector(s);
    const videoEl = $("#video");
    let pc, dcR, dcU; // reliable / unreliable
    let forceStop = false;
    const BLOCK_KEYS = [" ", "k", "MediaPlayPause"];

    // 追蹤目前「按住」的 pointers，便於頁面切換時補送 cancel
    const activePointers = new Set();

    const log = (...args) => {
      const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
      $("#log").textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      $("#log").scrollTop = $("#log").scrollHeight;
      console.log(...args);
    };

    // 永久關閉任何播放控制與菜單
    videoEl.controls = false;
    videoEl.setAttribute("disablepictureinpicture", "");
    videoEl.setAttribute("disableremoteplayback", "");
    videoEl.setAttribute("controlslist", "nodownload noplaybackrate noremoteplayback nofullscreen");
    videoEl.addEventListener("contextmenu", e => e.preventDefault());
    ["click","dblclick"].forEach(type => videoEl.addEventListener(type, e => e.preventDefault(), { capture:true }));
    videoEl.addEventListener("pause", () => { if (!forceStop) videoEl.play().catch(()=>{}); });
    window.addEventListener("keydown", (e) => { if (BLOCK_KEYS.includes(e.key)) e.preventDefault(); }, { capture: true });

    // ======= 顯示區與座標換算（扣黑邊 → 原生像素）=======
    function computeDisplayRect() {
      const r = videoEl.getBoundingClientRect();
      const vw = videoEl.videoWidth  || r.width;
      const vh = videoEl.videoHeight || r.height;
      const scale = Math.min(r.width / vw, r.height / vh);
      const displayW = vw * scale;
      const displayH = vh * scale;
      const offsetX = (r.width  - displayW) / 2;
      const offsetY = (r.height - displayH) / 2;
      return { box: r, vw, vh, displayW, displayH, offsetX, offsetY };
    }

    function mapToVideoPixel(e) {
      const { box: r, vw, vh, displayW, displayH, offsetX, offsetY } = computeDisplayRect();
      const xPx = e.clientX - r.left - offsetX;
      const yPx = e.clientY - r.top  - offsetY;
      if (xPx < 0 || yPx < 0 || xPx > displayW || yPx > displayH) return { inside: false };
      const nx = displayW > 0 ? (xPx / displayW) : 0;
      const ny = displayH > 0 ? (yPx / displayH) : 0;
      const ix = Math.round(nx * vw);
      const iy = Math.round(ny * vh);
      return { inside: true, ix, iy };
    }

    // ======= DataChannel：可靠/不可靠 =======
    function dcOpen(dc)  { log(`DataChannel open: ${dc.label} (ordered=${dc.ordered}, maxRetransmits=${dc.maxRetransmits ?? "∞"})`); }
    function dcClose(dc) { log(`DataChannel closed: ${dc.label}`); }
    function dcError(dc, e) { log(`DataChannel error: ${dc.label}`, e?.message || e); }

    function sendOn(dc, payload) {
      if (!dc || dc.readyState !== "open") return false;
      try {
        const txt = JSON.stringify(payload);
        dc.send(txt);
        return true;
      } catch (e) {
        log("DC send error", e?.message || e);
        return false;
      }
    }

    function sendControl(payload, reliable = true) {
      // 加上 video 原生寬高與 pointerType
      payload.screenW = videoEl.videoWidth  | 0;
      payload.screenH = videoEl.videoHeight | 0;
      // 按鈕與壓力數值沿用
      if (reliable) {
        if (sendOn(dcR, payload)) return true;
        return sendOn(dcU, payload);
      } else {
        if (sendOn(dcU, payload)) return true;
        return sendOn(dcR, payload);
      }
    }

    // ======= PointerEvent → Android MotionEvent 對映 =======
    // DOM event.button: [0]=Left, [1]=Middle, [2]=Right, [3]=Back, [4]=Forward
    // Android MotionEventButton: Primary(1), Tertiary(4), Secondary(2), Back(8), Forward(16)
    const PointerEventButtonToAndroidButton = [1, 4, 2, 8, 16];

    let lastMoveSent = 0;
    const MOVE_INTERVAL_MS = 10; // 輕微節流避免擁塞

    function sendTouch(type, e) {
      const m = mapToVideoPixel(e);
      if (!m.inside) return;

      // 依事件型別填 actionButton
      let actionButton = 0;
      if (type === "down" || type === "up") {
        const idx = e.button ?? 0;
        actionButton = PointerEventButtonToAndroidButton[idx] || 1;
      }

      const payload = {
        type,                 // "down" | "move" | "up" | "cancel"
        id: e.pointerId,
        x: m.ix, y: m.iy,
        pressure: e.pressure ?? 0,
        buttons:  e.buttons  ?? 0,
        actionButton,
        pointerType: e.pointerType || "mouse"
      };

      if (type === "move") {
        const now = performance.now();
        if (now - lastMoveSent < MOVE_INTERVAL_MS) return;
        lastMoveSent = now;
        sendControl(payload, /*reliable=*/false);
      } else {
        // down/up/cancel 一律可靠通道，避免遺失
        sendControl(payload, /*reliable=*/true);
        log(`touch:${type}`, payload);
      }
    }

    // 指針事件（多指）
    videoEl.addEventListener("pointerdown", (e) => {
      videoEl.setPointerCapture?.(e.pointerId);
      activePointers.add(e.pointerId);
      sendTouch("down", e);
      e.preventDefault();
    }, { passive:false });

    videoEl.addEventListener("pointermove", (e) => {
      if (e.pressure !== 0 || e.buttons) sendTouch("move", e);
      e.preventDefault();
    }, { passive:false });

    function finishPointer(e, kind) {
      try { videoEl.releasePointerCapture?.(e.pointerId); } catch {}
      activePointers.delete(e.pointerId);
      sendTouch(kind, e);
    }

    videoEl.addEventListener("pointerup", (e) => {
      finishPointer(e, "up");
      e.preventDefault();
    }, { passive:false });

    videoEl.addEventListener("pointercancel", (e) => {
      finishPointer(e, "cancel");
      e.preventDefault();
    }, { passive:false });

    // 頁面切換/隱藏時，保險補送 cancel（避免殘留按住狀態）
    function cancelAllActivePointers() {
      for (const id of Array.from(activePointers)) {
        const fake = new PointerEvent("pointercancel", { pointerId: id, clientX: 0, clientY: 0, buttons: 0, pressure: 0 });
        finishPointer(fake, "cancel");
      }
    }
    window.addEventListener("visibilitychange", () => { if (document.hidden) cancelAllActivePointers(); });
    window.addEventListener("pagehide", cancelAllActivePointers);
    window.addEventListener("beforeunload", cancelAllActivePointers);

    // 顯示影片尺寸變化
    videoEl.addEventListener("loadedmetadata", () => {
      const r = videoEl.getBoundingClientRect();
      log("video meta", { vw: videoEl.videoWidth, vh: videoEl.videoHeight, cw: Math.round(r.width), ch: Math.round(r.height) });
    });

    // ======= WebRTC =======
    function waitForIceComplete(pc) {
      return new Promise(resolve => {
        if (pc.iceGatheringState === "complete") return resolve();
        function check() {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", check);
            resolve();
          }
        }
        pc.addEventListener("icegatheringstatechange", check);
      });
    }

    async function start() {
      try {
        $("#btnStart").disabled = true;
        $("#btnStop").disabled = false;
        forceStop = false;

        // 設定 ADB 目標
        const adbTargetValue = $("#adbTarget").value.trim();
        if (adbTargetValue) {
          log(`設定 ADB 目標: ${adbTargetValue}`);
          const targetResp = await fetch("/set-adb-target", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ target: adbTargetValue }),
          });
          if (!targetResp.ok) {
            throw new Error(`設定 ADB 目標失敗: ${targetResp.status} ${targetResp.statusText}`);
          }
          const targetResult = await targetResp.json();
          log(`ADB 目標已設定: ${targetResult.target}`);
        }

        pc = new RTCPeerConnection();

        // 控制用雙通道
        dcR = pc.createDataChannel("controlR", { ordered: true });
        dcU = pc.createDataChannel("controlU", { ordered: false, maxRetransmits: 0 });
        [dcR, dcU].forEach(dc => {
          dc.onopen  = () => dcOpen(dc);
          dc.onclose = () => dcClose(dc);
          dc.onerror = (e) => dcError(dc, e);
        });

        // 顯示遠端影像
        pc.ontrack = (e) => {
          if (!videoEl.srcObject) {
            videoEl.srcObject = e.streams[0];
            videoEl.play().catch(()=>{});
          }
        };

        // 收視訊（recvonly），優先 H.264
        const transceiver = pc.addTransceiver("video", { direction: "recvonly" });
        const caps = RTCRtpReceiver.getCapabilities("video");
        if (caps && caps.codecs) {
          const h264 = caps.codecs.filter(c => (c.mimeType || c.mimeTypeCanonical || '').toLowerCase() === "video/h264");
          if (h264.length) {
            transceiver.setCodecPreferences(h264);
            log("使用 H.264 codec 偏好。");
          } else {
            log("找不到 H.264 能力，瀏覽器可能不支援。");
          }
        }

        pc.onconnectionstatechange     = () => log("PeerConnection:", pc.connectionState);
        pc.oniceconnectionstatechange  = () => log("ICE:", pc.iceConnectionState);
        pc.onicegatheringstatechange   = () => log("ICE Gathering:", pc.iceGatheringState);
        pc.onicecandidateerror         = (e) => log("ICE Candidate Error:", e.errorText || e);

        // SDP 交換（non-trickle）
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceComplete(pc);

        const resp = await fetch("/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(pc.localDescription),
        });
        if (!resp.ok) throw new Error(`Offer 送出失敗: ${resp.status} ${resp.statusText}`);
        const answer = await resp.json();

        await pc.setRemoteDescription(answer);
        log("WebRTC 已連線，等待畫面…");
      } catch (err) {
        log("連線發生錯誤：", err);
        $("#btnStart").disabled = false;
        $("#btnStop").disabled = true;
      }
    }

    async function stop() {
      try {
        $("#btnStop").disabled = true;
        forceStop = true; // 防止 pause 事件自動恢復播放
        cancelAllActivePointers();
        if (pc) {
          pc.getTransceivers().forEach(t => t.stop && t.stop());
          pc.getSenders().forEach(s => s.track && s.track.stop());
          pc.getReceivers().forEach(r => r.track && r.track.stop());
          pc.close();
          pc = null;
        }
        if (videoEl.srcObject) {
          videoEl.srcObject.getTracks().forEach(t => t.stop());
          videoEl.srcObject = null;
        }
        log("已中斷連線。");
      } finally {
        $("#btnStart").disabled = false;
      }
    }

    $("#btnStart").addEventListener("click", start);
    $("#btnStop").addEventListener("click", stop);
    $("#btnReconnectAndroid").addEventListener("click", async () => {
      log("重新連接 Android...");
      await stop();
      setTimeout(start, 1000); // 等待 1 秒後重連
    });

    // 自動嘗試連線
    start();
  </script>
</body>
</html>
