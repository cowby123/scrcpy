<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>scrcpy WebRTC Demo</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#111; display:flex; gap:16px; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial; }
    header { color:#ddd; opacity:.9; }
    video {
      width:min(92vw, 900px);
      max-height:80vh;
      background:black;
      border-radius:12px;
      box-shadow:0 6px 30px rgba(0,0,0,.35);
      /* 為了能接收原始多指觸控/手勢，交給 JS 處理 */
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .row { display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
    button { padding:10px 16px; border-radius:10px; border:1px solid #333; background:#1f1f1f; color:#ddd; cursor:pointer; }
    button:hover { background:#262626; }
    pre { width:min(92vw, 900px); max-height:22vh; overflow:auto; background:#0c0c0c; color:#bbb; border:1px solid #222; border-radius:10px; padding:10px; }
  </style>
</head>
<body>
  <header>
    <h2>scrcpy WebRTC Demo</h2>
  </header>

  <!-- 拿掉 controls，並封鎖 PiP/Cast/倍速/全螢幕 -->
  <video id="video" autoplay playsinline muted
         disablepictureinpicture
         disableremoteplayback
         controlslist="nodownload noplaybackrate noremoteplayback nofullscreen"></video>

  <div class="row">
    <button id="btnStart">開始連線</button>
    <button id="btnStop" disabled>中斷連線</button>
  </div>

  <pre id="log" aria-label="log"></pre>

  <script>
    const $ = (s)=>document.querySelector(s);
    const log = (...args) => {
      const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
      $("#log").textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      $("#log").scrollTop = $("#log").scrollHeight;
      console.log(...args);
    };

    let pc;
    const videoEl = $("#video");
    const BLOCK_KEYS = [" ", "k", "MediaPlayPause"];
    let forceStop = false;

    // 永久關閉任何播放控制與菜單
    videoEl.controls = false;
    videoEl.setAttribute("disablepictureinpicture", "");
    videoEl.setAttribute("disableremoteplayback", "");
    videoEl.setAttribute("controlslist", "nodownload noplaybackrate noremoteplayback nofullscreen");
    videoEl.addEventListener("contextmenu", e => e.preventDefault());
    // 阻止點擊/雙擊造成全螢幕或暫停
    ["click","dblclick"].forEach(type => videoEl.addEventListener(type, e => e.preventDefault(), { capture:true }));

    // 若外部嘗試暫停，立刻恢復播放（除非是我們主動 stop）
    videoEl.addEventListener("pause", () => { if (!forceStop) videoEl.play().catch(()=>{}); });

    // 阻擋鍵盤的播放/暫停快捷鍵
    window.addEventListener("keydown", (e) => {
      if (BLOCK_KEYS.includes(e.key)) e.preventDefault();
    }, { capture: true });

    // ===== 觸控/指針事件骨架（保留互動，不影響未來傳 ADB） =====
    function normPoint(e) {
      const r = videoEl.getBoundingClientRect();
      const x = (e.clientX - r.left) / r.width;
      const y = (e.clientY - r.top) / r.height;
      return { x, y, w: r.width, h: r.height };
    }
    function sendTouch(type, e) {
      const p = normPoint(e);
      // TODO: 在這裡把事件送到後端（例如 POST /control）
      log(`touch:${type}`, { id: e.pointerId, x: +p.x.toFixed(4), y: +p.y.toFixed(4), b: e.buttons||0, pr: e.pressure||0 });
    }
    videoEl.addEventListener("pointerdown", (e) => {
      videoEl.setPointerCapture?.(e.pointerId);
      sendTouch("down", e);
      e.preventDefault();
    }, { passive:false });
    videoEl.addEventListener("pointermove", (e) => {
      if (e.pressure !== 0 || e.buttons) sendTouch("move", e);
      e.preventDefault();
    }, { passive:false });
    videoEl.addEventListener("pointerup", (e) => {
      sendTouch("up", e);
      e.preventDefault();
    }, { passive:false });
    videoEl.addEventListener("pointercancel", (e) => {
      sendTouch("cancel", e);
      e.preventDefault();
    }, { passive:false });
    // ======================================================

    function waitForIceComplete(pc) {
      return new Promise(resolve => {
        if (pc.iceGatheringState === "complete") return resolve();
        function check() {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", check);
            resolve();
          }
        }
        pc.addEventListener("icegatheringstatechange", check);
      });
    }

    async function start() {
      try {
        $("#btnStart").disabled = true;
        $("#btnStop").disabled = false;
        forceStop = false;

        pc = new RTCPeerConnection();

        // 顯示遠端影像
        pc.ontrack = (e) => {
          if (!videoEl.srcObject) {
            videoEl.srcObject = e.streams[0];
            // 某些瀏覽器需要顯式 play()
            videoEl.play().catch(()=>{});
          }
        };

        // 收視訊（recvonly），並優先 H.264
        const transceiver = pc.addTransceiver("video", { direction: "recvonly" });
        const caps = RTCRtpReceiver.getCapabilities("video");
        if (caps && caps.codecs) {
          const h264 = caps.codecs.filter(c => (c.mimeType || c.mimeTypeCanonical || '').toLowerCase() === "video/h264");
          if (h264.length) {
            transceiver.setCodecPreferences(h264);
            log("使用 H.264 codec 偏好。");
          } else {
            log("找不到 H.264 能力，瀏覽器可能不支援。");
          }
        }

        // 事件監控
        pc.onconnectionstatechange = () => log("PeerConnection:", pc.connectionState);
        pc.oniceconnectionstatechange = () => log("ICE:", pc.iceConnectionState);
        pc.onicegatheringstatechange = () => log("ICE Gathering:", pc.iceGatheringState);
        pc.onicecandidateerror = (e) => log("ICE Candidate Error:", e.errorText || e);

        // 產生 Offer 並等待 ICE 完成（與後端 non-trickle 對齊）
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceComplete(pc);

        // 傳送給 Go backend
        const resp = await fetch("/offer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(pc.localDescription),
        });
        if (!resp.ok) throw new Error(`Offer 送出失敗: ${resp.status} ${resp.statusText}`);
        const answer = await resp.json();

        await pc.setRemoteDescription(answer);
        log("WebRTC 已連線，等待畫面…");
      } catch (err) {
        log("連線發生錯誤：", err);
        $("#btnStart").disabled = false;
        $("#btnStop").disabled = true;
      }
    }

    async function stop() {
      try {
        $("#btnStop").disabled = true;
        forceStop = true; // 防止 pause 事件自動恢復播放
        if (pc) {
          pc.getTransceivers().forEach(t => t.stop && t.stop());
          pc.getSenders().forEach(s => s.track && s.track.stop());
          pc.getReceivers().forEach(r => r.track && r.track.stop());
          pc.close();
          pc = null;
        }
        if (videoEl.srcObject) {
          videoEl.srcObject.getTracks().forEach(t => t.stop());
          videoEl.srcObject = null;
        }
        log("已中斷連線。");
      } finally {
        $("#btnStart").disabled = false;
      }
    }

    $("#btnStart").addEventListener("click", start);
    $("#btnStop").addEventListener("click", stop);

    // 自動嘗試連線（可手動改成只按鈕觸發）
    start();
  </script>
</body>
</html>
